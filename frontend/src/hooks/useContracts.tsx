import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';\nimport { ethers } from 'ethers';\nimport { useWeb3React } from '@web3-react/core';\nimport toast from 'react-hot-toast';\n\n// Contract ABIs (simplified for demo - in production, import from generated files)\nconst PRICE_MONITOR_ABI = [\n  'function getFeedCount() view returns (uint256)',\n  'function getTreasuryCount() view returns (uint256)',\n  'function addPriceFeed(bytes32 feedId, address feedAddress, uint256 chainId, uint256 threshold)',\n  'function addTreasury(uint256 chainId, address treasuryAddress, uint64 gasLimit)',\n  'event PriceThresholdBreached(bytes32 indexed feedId, int256 oldPrice, int256 newPrice, uint256 changePercent, uint256 timestamp)',\n  'event RebalanceTriggered(uint256 indexed chainId, address indexed treasury, bytes32 feedId, int256 price)'\n];\n\nconst TREASURY_VAULT_ABI = [\n  'function getPortfolioState() view returns (uint256 totalValue, uint256 lastRebalance, uint256 rebalanceCount)',\n  'function getAssetAllocation(bytes32 assetId) view returns (address token, uint256 balance, uint256 targetAllocation, uint256 currentAllocation)',\n  'function isPaused() view returns (bool)',\n  'function addAsset(bytes32 assetId, address token, uint256 targetAllocation, uint256 minBalance)',\n  'function executeRebalance(bytes32 feedId, int256 currentPrice, uint256 changePercent)',\n  'function pause()',\n  'function unpause()',\n  'function updateAssetAllocation(bytes32 assetId, uint256 newAllocation)',\n  'event RebalanceExecuted(bytes32 indexed feedId, address indexed tokenFrom, address indexed tokenTo, uint256 amount, int256 triggerPrice)',\n  'event EmergencyPaused(address indexed by, uint256 timestamp)'\n];\n\n// Contract addresses (will be set via environment variables)\nconst CONTRACT_ADDRESSES = {\n  PRICE_MONITOR: {\n    5318008: process.env.REACT_APP_REACTIVE_PRICE_MONITOR || '', // Reactive Network\n  },\n  TREASURY_VAULT: {\n    11155111: process.env.REACT_APP_SEPOLIA_TREASURY || '', // Sepolia\n    421614: process.env.REACT_APP_ARBITRUM_TREASURY || '', // Arbitrum Sepolia\n  }\n};\n\ninterface ContractsContextType {\n  priceMonitor: ethers.Contract | null;\n  treasuryVault: ethers.Contract | null;\n  isLoading: boolean;\n  error: string | null;\n  switchToReactiveNetwork: () => Promise<void>;\n  switchToChain: (chainId: number) => Promise<void>;\n  getContractAddress: (contract: string, chainId?: number) => string;\n}\n\nconst ContractsContext = createContext<ContractsContextType | undefined>(undefined);\n\ninterface ContractProviderProps {\n  children: ReactNode;\n}\n\nexport const ContractProvider: React.FC<ContractProviderProps> = ({ children }) => {\n  const { active, library, chainId, account } = useWeb3React();\n  const [priceMonitor, setPriceMonitor] = useState<ethers.Contract | null>(null);\n  const [treasuryVault, setTreasuryVault] = useState<ethers.Contract | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    if (active && library && chainId) {\n      loadContracts();\n    } else {\n      setPriceMonitor(null);\n      setTreasuryVault(null);\n    }\n  }, [active, library, chainId, account]);\n\n  const loadContracts = async () => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const signer = library.getSigner();\n\n      // Load PriceMonitor on Reactive Network\n      const priceMonitorAddress = CONTRACT_ADDRESSES.PRICE_MONITOR[5318008];\n      if (priceMonitorAddress && chainId === 5318008) {\n        const priceMonitorContract = new ethers.Contract(\n          priceMonitorAddress,\n          PRICE_MONITOR_ABI,\n          signer\n        );\n        setPriceMonitor(priceMonitorContract);\n      }\n\n      // Load TreasuryVault on current chain\n      const treasuryAddress = CONTRACT_ADDRESSES.TREASURY_VAULT[chainId as keyof typeof CONTRACT_ADDRESSES.TREASURY_VAULT];\n      if (treasuryAddress) {\n        const treasuryContract = new ethers.Contract(\n          treasuryAddress,\n          TREASURY_VAULT_ABI,\n          signer\n        );\n        setTreasuryVault(treasuryContract);\n      }\n\n    } catch (err: any) {\n      console.error('Failed to load contracts:', err);\n      setError(err.message || 'Failed to load contracts');\n      toast.error('Failed to load contracts');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const switchToReactiveNetwork = async () => {\n    try {\n      await library.provider.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{ chainId: '0x512398' }], // 5318008 in hex\n      });\n    } catch (switchError: any) {\n      // This error code indicates that the chain has not been added to MetaMask\n      if (switchError.code === 4902) {\n        try {\n          await library.provider.request({\n            method: 'wallet_addEthereumChain',\n            params: [\n              {\n                chainId: '0x512398',\n                chainName: 'Reactive Network',\n                nativeCurrency: {\n                  name: 'REACT',\n                  symbol: 'REACT',\n                  decimals: 18,\n                },\n                rpcUrls: ['https://rpc.reactive.network'],\n                blockExplorerUrls: ['https://explorer.reactive.network'],\n              },\n            ],\n          });\n        } catch (addError) {\n          console.error('Failed to add Reactive Network:', addError);\n          toast.error('Failed to add Reactive Network to wallet');\n        }\n      } else {\n        console.error('Failed to switch to Reactive Network:', switchError);\n        toast.error('Failed to switch to Reactive Network');\n      }\n    }\n  };\n\n  const switchToChain = async (targetChainId: number) => {\n    try {\n      await library.provider.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{ chainId: `0x${targetChainId.toString(16)}` }],\n      });\n    } catch (error: any) {\n      console.error(`Failed to switch to chain ${targetChainId}:`, error);\n      toast.error(`Failed to switch to chain ${targetChainId}`);\n    }\n  };\n\n  const getContractAddress = (contract: string, targetChainId?: number) => {\n    const currentChainId = targetChainId || chainId;\n    \n    switch (contract) {\n      case 'PRICE_MONITOR':\n        return CONTRACT_ADDRESSES.PRICE_MONITOR[5318008] || '';\n      case 'TREASURY_VAULT':\n        return CONTRACT_ADDRESSES.TREASURY_VAULT[currentChainId as keyof typeof CONTRACT_ADDRESSES.TREASURY_VAULT] || '';\n      default:\n        return '';\n    }\n  };\n\n  const contextValue: ContractsContextType = {\n    priceMonitor,\n    treasuryVault,\n    isLoading,\n    error,\n    switchToReactiveNetwork,\n    switchToChain,\n    getContractAddress,\n  };\n\n  return (\n    <ContractsContext.Provider value={contextValue}>\n      {children}\n    </ContractsContext.Provider>\n  );\n};\n\nexport const useContracts = (): ContractsContextType => {\n  const context = useContext(ContractsContext);\n  if (context === undefined) {\n    throw new Error('useContracts must be used within a ContractProvider');\n  }\n  return context;\n};\n\n// Hook for listening to contract events\nexport const useContractEvents = () => {\n  const { priceMonitor, treasuryVault } = useContracts();\n  const [events, setEvents] = useState<any[]>([]);\n\n  useEffect(() => {\n    if (!priceMonitor && !treasuryVault) return;\n\n    const eventListeners: any[] = [];\n\n    // Listen to PriceMonitor events\n    if (priceMonitor) {\n      const onPriceThresholdBreached = (feedId: string, oldPrice: any, newPrice: any, changePercent: any, timestamp: any, event: any) => {\n        const newEvent = {\n          type: 'PriceThresholdBreached',\n          data: { feedId, oldPrice, newPrice, changePercent, timestamp },\n          transactionHash: event.transactionHash,\n          blockNumber: event.blockNumber,\n          timestamp: new Date(),\n        };\n        setEvents(prev => [newEvent, ...prev.slice(0, 49)]); // Keep last 50 events\n        toast.success(`Price threshold breached: ${(changePercent / 100).toFixed(2)}%`);\n      };\n\n      const onRebalanceTriggered = (chainId: any, treasury: string, feedId: string, price: any, event: any) => {\n        const newEvent = {\n          type: 'RebalanceTriggered',\n          data: { chainId, treasury, feedId, price },\n          transactionHash: event.transactionHash,\n          blockNumber: event.blockNumber,\n          timestamp: new Date(),\n        };\n        setEvents(prev => [newEvent, ...prev.slice(0, 49)]);\n        toast.success('Rebalancing triggered!');\n      };\n\n      priceMonitor.on('PriceThresholdBreached', onPriceThresholdBreached);\n      priceMonitor.on('RebalanceTriggered', onRebalanceTriggered);\n\n      eventListeners.push(\n        () => priceMonitor.off('PriceThresholdBreached', onPriceThresholdBreached),\n        () => priceMonitor.off('RebalanceTriggered', onRebalanceTriggered)\n      );\n    }\n\n    // Listen to TreasuryVault events\n    if (treasuryVault) {\n      const onRebalanceExecuted = (feedId: string, tokenFrom: string, tokenTo: string, amount: any, triggerPrice: any, event: any) => {\n        const newEvent = {\n          type: 'RebalanceExecuted',\n          data: { feedId, tokenFrom, tokenTo, amount, triggerPrice },\n          transactionHash: event.transactionHash,\n          blockNumber: event.blockNumber,\n          timestamp: new Date(),\n        };\n        setEvents(prev => [newEvent, ...prev.slice(0, 49)]);\n        toast.success('Rebalancing executed successfully!');\n      };\n\n      const onEmergencyPaused = (by: string, timestamp: any, event: any) => {\n        const newEvent = {\n          type: 'EmergencyPaused',\n          data: { by, timestamp },\n          transactionHash: event.transactionHash,\n          blockNumber: event.blockNumber,\n          timestamp: new Date(),\n        };\n        setEvents(prev => [newEvent, ...prev.slice(0, 49)]);\n        toast.error('System paused by emergency action!');\n      };\n\n      treasuryVault.on('RebalanceExecuted', onRebalanceExecuted);\n      treasuryVault.on('EmergencyPaused', onEmergencyPaused);\n\n      eventListeners.push(\n        () => treasuryVault.off('RebalanceExecuted', onRebalanceExecuted),\n        () => treasuryVault.off('EmergencyPaused', onEmergencyPaused)\n      );\n    }\n\n    // Cleanup function\n    return () => {\n      eventListeners.forEach(cleanup => cleanup());\n    };\n  }, [priceMonitor, treasuryVault]);\n\n  return { events };\n};